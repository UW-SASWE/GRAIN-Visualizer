<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GRAIN Visualizer</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- MapLibre CSS -->
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link href="css/style.css" rel="stylesheet" />
</head>

<body>
    <!-- 1. Header -->
    <header>
        <div class="header-title"><span class="brand-strong">GRAIN</span> <span class="brand-muted">Visualizer</span></div>
        <nav class="header-nav">
            <a class="header-doc-link" href="https://grain-canals.readthedocs.io/en/latest/" target="_blank" rel="noopener">Documentation</a>
            <a href="disclaimer.html" target="_blank" rel="noopener">Disclaimer</a>
        </nav>
    </header>

    <!-- 2. Sidebar -->
    <aside>
        <div class="logo-placeholder">
            <img src="assets/grain_logo.png" alt="GRAIN logo" />
        </div>

        <div class="panel-section">
            <div class="panel-title">Region Selection</div>
            <select class="grain-input" id="country-select">
                <option value="global">Global View</option>
                <option disabled>──────────</option>
                <option value="IN">India</option>
                <option value="CN">China</option>
                <option value="US">United States</option>
                <!-- More options will be populated dynamically -->
            </select>
        </div>

        <div class="panel-section">
            <div class="panel-title">Stats</div>
            <div class="stat-grid">
                <!-- Box 1: Length -->
                <div class="stat-box blue">
                    <span class="stat-label">Total Length</span>
                    <div>
                        <span class="stat-value" id="stat-length">3.82</span>
                        <span class="stat-unit" id="stat-length-unit">million km</span>
                    </div>
                </div>
                <!-- Box 2: Cropland Area -->
                <div class="stat-box amber">
                    <span class="stat-label">Cropland Area</span>
                    <div>
                        <span class="stat-value" id="stat-cropland">39.48</span>
                        <span class="stat-unit" id="stat-cropland-unit">million km<sup>2</sup></span>
                    </div>
                </div>
                <!-- Box 3: Density -->
                <div class="stat-box green" style="grid-column: span 2;">
                    <span class="stat-label">Canal Density</span>
                    <div>
                        <span class="stat-value" id="stat-density">200.1</span>
                        <span class="stat-unit" id="stat-density-unit">km/1000km<sup>2</sup> of cropland</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <button class="insights-tab insights-tab--sidebar" type="button" id="insights-tab" aria-controls="insights-panel" aria-expanded="false">
                Insights
            </button>
        </div>

        <div class="panel-section">
            <div class="panel-title">Download Data</div>
            <a class="download-button" href="https://doi.org/10.5281/zenodo.16786488" target="_blank" rel="noopener">
                Download Full Dataset
            </a>
        </div>
    </aside>

    <!-- 3. Map Area -->
    <main id="map">
        <div class="map-control-card">
            <span>Basemap</span>
            <select id="basemap-select">
                <option value="standard" selected>Standard</option>
                <option value="satellite">Satellite</option>
                <option value="night">Night</option>
            </select>
        </div>
        <div class="map-control-card map-toggle-card">
            <label class="canal-toggle">
                <span class="canal-toggle-text">Toggle Canals</span>
                <input type="checkbox" id="canals-toggle" class="canal-switch-input" checked />
                <span class="canal-switch" aria-hidden="true"></span>
            </label>
        </div>
        <section class="insights-panel" id="insights-panel" aria-hidden="true">
            <div class="insights-header">
                <span class="insights-title">Insights</span>
                <div class="insights-tabs" role="tablist" aria-label="Insights data">
                    <button class="insights-tab-button" type="button" data-insights-tab="length" role="tab" aria-selected="true">
                        Length
                    </button>
                    <button class="insights-tab-button" type="button" data-insights-tab="density" role="tab" aria-selected="false">
                        Density
                    </button>
                    <button class="insights-tab-button" type="button" data-insights-tab="yield" role="tab" aria-selected="false">
                        Cereal Yield
                    </button>
                </div>
                <button class="insights-close" type="button" id="insights-close" aria-label="Close insights panel">×</button>
            </div>
            <div class="insights-body">
                <div class="insights-content" data-insights-panel="length">
                    <div class="insights-map-card">
                        <canvas id="length-choropleth" aria-label="Length choropleth map" role="img"></canvas>
                        <div class="insights-legend-title">Canal length (km)</div>
                        <div class="insights-legend">
                            <span class="insights-legend-label" id="length-legend-min">0</span>
                            <div class="insights-legend-bar" id="length-legend-bar"></div>
                            <span class="insights-legend-label" id="length-legend-max">0</span>
                        </div>
                    </div>
                    <div class="insights-side-card">
                        <div class="insights-side-title">Top by length</div>
                        <div class="insights-bars" id="length-bars"></div>
                    </div>
                </div>
                <div class="insights-content" data-insights-panel="density" hidden>
                    <div class="insights-map-card">
                        <canvas id="density-choropleth" aria-label="Density choropleth map" role="img"></canvas>
                        <div class="insights-legend-title">Canal Density (km<sup>2</sup>/1000 km<sup>2</sup> of cropland)</div>
                        <div class="insights-legend">
                            <span class="insights-legend-label" id="density-legend-min">0</span>
                            <div class="insights-legend-bar" id="density-legend-bar"></div>
                            <span class="insights-legend-label" id="density-legend-max">0</span>
                        </div>
                    </div>
                    <div class="insights-side-card">
                        <div class="insights-side-title">Top by density</div>
                        <div class="insights-bars" id="density-bars"></div>
                    </div>
                </div>
                <div class="insights-content" data-insights-panel="yield" hidden>
                    <div class="insights-map-card insights-map-card--scatter">
                        <canvas id="yield-scatterplot" aria-label="Cereal yield scatterplot" role="img"></canvas>
                        <div class="scatter-tooltip" id="yield-tooltip" role="status" aria-hidden="true"></div>
                    </div>
                    <div class="insights-side-card">
                        <div class="insights-legend-block">
                            <div class="insights-legend-heading">Continent</div>
                            <div class="insights-legend insights-legend--vertical" id="yield-legend"></div>
                        </div>
                        <div class="insights-legend-block" id="yield-size-legend">
                            <div class="insights-legend-heading">Canal length</div>
                            <div class="insights-legend-size">
                                <div class="insights-legend-size-row">
                                    <span class="insights-legend-size-dot insights-legend-size-dot--small"></span>
                                    <span class="insights-legend-label" id="yield-size-small">Small</span>
                                </div>
                                <div class="insights-legend-size-row">
                                    <span class="insights-legend-size-dot insights-legend-size-dot--medium"></span>
                                    <span class="insights-legend-label" id="yield-size-medium">Medium</span>
                                </div>
                                <div class="insights-legend-size-row">
                                    <span class="insights-legend-size-dot insights-legend-size-dot--large"></span>
                                    <span class="insights-legend-label" id="yield-size-large">Large</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <div class="map-logo">
            <a href="https://saswe.net" target="_blank" rel="noopener">
                <img class="logo-saswe" src="assets/saswe_logo.png" alt="SASWE logo" />
            </a>
            <img class="logo-uw" src="assets/uw_logo.png" alt="University of Washington logo" />
        </div>
    </main>

    <!-- 4. Footer -->
    <footer>
        <div class="footer-logos">
            <span class="footer-logo-text footer-logo-uw">
                <span class="footer-logo-sub">Maintained by </span>
                <span class="footer-strong">Sarath Suresh</span>
                <span class="footer-logo-sub">, University of Washington</span>
            </span>
        </div>
        <div class="footer-logos">
            <span class="footer-logo-text footer-logo-sub">Data hosted on <span class="footer-strong">Cloudflare R2</span></span>
            <img class="footer-cloudflare-logo" src="assets/cloudflare_logo.png" alt="Cloudflare logo" />
        </div>
    </footer>

    <!-- MapLibre JS -->
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

    <!-- PMTiles UMD build (IMPORTANT) -->
    <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>

    <script>
        // 1️⃣ Register PMTiles protocol BEFORE creating map
        const protocol = new pmtiles.Protocol();
        maplibregl.addProtocol("pmtiles", protocol.tile);

        console.log("pmtiles global:", pmtiles);

        // 2️⃣ PMTiles URL (long path, as requested)
        const PMTILES_URL =
            "https://pub-9a261f2211db4953b44c3cb6016ab4e8.r2.dev/pmtiles/v1.0/grain_global_v1_0.pmtiles";

        // 3️⃣ Create map with simple OSM basemap
        const map = new maplibregl.Map({
            container: "map",
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: "raster",
                        tiles: ["https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}"],
                        tileSize: 256,
                        attribution: "© Esri"
                    },
                    esri_imagery: {
                        type: "raster",
                        tiles: ["https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"],
                        tileSize: 256,
                        attribution: "© Esri"
                    },
                    carto_dark: {
                        type: "raster",
                        tiles: [
                            "https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png",
                            "https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png",
                            "https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png"
                        ],
                        tileSize: 256,
                        attribution: "© OpenStreetMap contributors © CARTO"
                    }
                },
                layers: [
                    { id: "osm", type: "raster", source: "osm" },
                    { id: "esri-imagery", type: "raster", source: "esri_imagery", layout: { visibility: "none" } },
                    { id: "carto-dark", type: "raster", source: "carto_dark", layout: { visibility: "none" } }
                ]
            },
            center: [0, 20],
            zoom: 1
        });

        map.addControl(new maplibregl.NavigationControl(), "top-right");
        const popup = new maplibregl.Popup({ closeButton: true, closeOnClick: true });
        const baseLineWidthExpr = [
            "interpolate", ["linear"], ["zoom"],
            2, 1,
            5, 1.0,
            8, 1.2,
            12, 2.3
        ];

        // 4️⃣ Add PMTiles vector source + layer
        map.on("load", () => {
            map.addSource("grain", {
                type: "vector",
                url: `pmtiles://${PMTILES_URL}`
            });

            // ⚠️ This must match the PMTiles internal layer name
            // We will fix this once you paste `pmtiles info` output
            const sourceLayer = "grain_canals";

            map.addLayer({
                id: "grain-lines",
                type: "line",
                source: "grain",
                "source-layer": sourceLayer,
                paint: {
                    "line-color": "blue", /* Tailwind blue-600 */
                    "line-opacity": 0.9,
                    "line-width": baseLineWidthExpr
                }
            });

            setCanalsVisibility();

            map.on("mouseenter", "grain-lines", () => {
                map.getCanvas().style.cursor = "pointer";
            });

            map.on("mouseleave", "grain-lines", () => {
                map.getCanvas().style.cursor = "";
            });

            map.on("click", "grain-lines", (e) => {
                const feature = e.features?.[0];
                if (!feature?.properties) {
                    return;
                }

                const rows = Object.entries(feature.properties)
                    .map(([key, value]) => {
                        const safeKey = String(key).replace(/_/g, " ");
                        const safeValue = value === null || value === undefined ? "—" : String(value);
                        return `<div style="display:flex;gap:8px;justify-content:space-between;"><strong>${safeKey}</strong><span>${safeValue}</span></div>`;
                    })
                    .join("");

                popup
                    .setLngLat(e.lngLat)
                    .setHTML(
                        `<div style="min-width:220px;font-size:12px;line-height:1.4;">` +
                            `${rows}` +
                            `<div style="margin-top:8px;font-size:11px;color:#64748b;">` +
                            `Download the full GRAIN data for more attributes` +
                            `</div>` +
                        `</div>`
                    )
                    .addTo(map);
            });

        });

        // 5️⃣ Explicit error handling
        map.on("error", (e) => {
            console.error("MapLibre error:", e);
        });

        map.on("sourcedata", (e) => {
            if (e.sourceId === "grain" && (e.isSourceLoaded || e.loaded)) {
                // sourceLoaded event can be spammy, but useful to confirm
            }
        });

        let baseLineColor = "blue";
        let selectedCountryIso = null;

        const updateGrainLineStyle = () => {
            if (!map.getLayer("grain-lines")) {
                return;
            }

            if (selectedCountryIso) {
                map.setPaintProperty("grain-lines", "line-color", [
                    "match",
                    ["get", "country_iso"],
                    selectedCountryIso,
                    "red",
                    baseLineColor
                ]);
                map.setPaintProperty("grain-lines", "line-width", [
                    "case",
                    ["==", ["get", "country_iso"], selectedCountryIso],
                    ["*", 1.6, baseLineWidthExpr],
                    baseLineWidthExpr
                ]);
            } else {
                map.setPaintProperty("grain-lines", "line-color", baseLineColor);
                map.setPaintProperty("grain-lines", "line-width", baseLineWidthExpr);
            }
        };

        const basemapSelect = document.getElementById("basemap-select");
        basemapSelect.addEventListener("change", () => {
            const selected = basemapSelect.value;
            const isStandard = selected === "standard";
            const isSatellite = selected === "satellite";
            const isNight = selected === "night";

            map.setLayoutProperty("osm", "visibility", isStandard ? "visible" : "none");
            map.setLayoutProperty("esri-imagery", "visibility", isSatellite ? "visible" : "none");
            map.setLayoutProperty("carto-dark", "visibility", isNight ? "visible" : "none");

            baseLineColor = isStandard ? "blue" : isSatellite ? "orange" : "#ffffff";
            updateGrainLineStyle();
        });

        const canalsToggle = document.getElementById("canals-toggle");
        const setCanalsVisibility = () => {
            if (!map.getLayer("grain-lines")) {
                return;
            }
            map.setLayoutProperty(
                "grain-lines",
                "visibility",
                canalsToggle.checked ? "visible" : "none"
            );
        };

        canalsToggle.addEventListener("change", setCanalsVisibility);

        const insightsTab = document.getElementById("insights-tab");
        const insightsClose = document.getElementById("insights-close");
        const insightsPanel = document.getElementById("insights-panel");
        const insightsPanels = document.querySelectorAll(".insights-content");
        const insightsButtons = document.querySelectorAll(".insights-tab-button");
        const yieldCanvas = document.getElementById("yield-scatterplot");
        const yieldTooltip = document.getElementById("yield-tooltip");

        const getTotalLength = (properties) =>
            (properties?.Agricultural || 0) +
            (properties?.urban_length || 0) +
            (properties?.navigational_length || 0) +
            (properties?.Other || 0);

        const getDensityValue = (properties) => properties?.canal_density || 0;

        const renderLengthBars = () => {
            const barsEl = document.getElementById("length-bars");
            if (!barsEl || !countryFeatures.length) {
                return;
            }

            const rows = countryFeatures
                .map((feature) => ({
                    name: feature?.properties?.name || "Unknown",
                    value: getTotalLength(feature?.properties)
                }))
                .filter((row) => Number.isFinite(row.value) && row.value > 0)
                .reduce((acc, row) => {
                    const existing = acc.get(row.name);
                    if (!existing || row.value > existing.value) {
                        acc.set(row.name, row);
                    }
                    return acc;
                }, new Map());

            const uniqueRows = Array.from(rows.values()).sort((a, b) => b.value - a.value);

            const maxValue = uniqueRows[0]?.value || 1;
            barsEl.innerHTML = "";

            uniqueRows.forEach((row, index) => {
                const wrapper = document.createElement("div");
                wrapper.className = "insights-bar-row";

                const label = document.createElement("div");
                label.className = "insights-bar-label";
                label.textContent = `${index + 1}. ${row.name}`;

                const barTrack = document.createElement("div");
                barTrack.className = "insights-bar-track";

                const barFill = document.createElement("div");
                barFill.className = "insights-bar-fill insights-bar-fill--length";
                barFill.style.width = `${Math.max(6, (row.value / maxValue) * 100)}%`;

                const value = document.createElement("div");
                value.className = "insights-bar-value";
                value.textContent = `${formatNumber(row.value, { maximumFractionDigits: 0 })} km`;

                barTrack.appendChild(barFill);
                wrapper.appendChild(label);
                wrapper.appendChild(barTrack);
                wrapper.appendChild(value);
                barsEl.appendChild(wrapper);
            });
        };

        const renderDensityBars = () => {
            const barsEl = document.getElementById("density-bars");
            if (!barsEl || !countryFeatures.length) {
                return;
            }

            const rows = countryFeatures
                .map((feature) => ({
                    name: feature?.properties?.name || "Unknown",
                    value: getDensityValue(feature?.properties)
                }))
                .filter((row) => Number.isFinite(row.value) && row.value > 0)
                .reduce((acc, row) => {
                    const existing = acc.get(row.name);
                    if (!existing || row.value > existing.value) {
                        acc.set(row.name, row);
                    }
                    return acc;
                }, new Map());

            const uniqueRows = Array.from(rows.values()).sort((a, b) => b.value - a.value);
            const maxValue = uniqueRows[0]?.value || 1;
            barsEl.innerHTML = "";

            uniqueRows.forEach((row, index) => {
                const wrapper = document.createElement("div");
                wrapper.className = "insights-bar-row";

                const label = document.createElement("div");
                label.className = "insights-bar-label";
                label.textContent = `${index + 1}. ${row.name}`;

                const barTrack = document.createElement("div");
                barTrack.className = "insights-bar-track";

                const barFill = document.createElement("div");
                barFill.className = "insights-bar-fill insights-bar-fill--density";
                barFill.style.width = `${Math.max(6, (row.value / maxValue) * 100)}%`;

                const value = document.createElement("div");
                value.className = "insights-bar-value";
                value.textContent = formatNumber(row.value, { maximumFractionDigits: 1 });

                barTrack.appendChild(barFill);
                wrapper.appendChild(label);
                wrapper.appendChild(barTrack);
                wrapper.appendChild(value);
                barsEl.appendChild(wrapper);
            });
        };

        const renderLengthChoropleth = () => {
            const canvas = document.getElementById("length-choropleth");
            if (!canvas || !countryFeatures.length) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return;
            }

            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);

            const ctx = canvas.getContext("2d");
            if (!ctx) {
                return;
            }
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);

            const values = countryFeatures
                .map((feature) => getTotalLength(feature?.properties))
                .filter((value) => Number.isFinite(value) && value > 0);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;

            const lengthPalette = [
                [254, 230, 170],
                [252, 211, 77],
                [190, 242, 100],
                [132, 204, 22],
                [22, 163, 74],
                [21, 128, 61],
                [22, 101, 52]
            ];

            const lerp = (a, b, t) => a + (b - a) * t;
            const samplePalette = (t) => {
                const scaled = t * (lengthPalette.length - 1);
                const idx = Math.floor(scaled);
                const frac = scaled - idx;
                const start = lengthPalette[idx];
                const end = lengthPalette[Math.min(idx + 1, lengthPalette.length - 1)];
                return [
                    Math.round(lerp(start[0], end[0], frac)),
                    Math.round(lerp(start[1], end[1], frac)),
                    Math.round(lerp(start[2], end[2], frac))
                ];
            };

            const project = ([lon, lat]) => {
                const x = ((lon + 180) / 360) * rect.width;
                const y = ((90 - lat) / 180) * rect.height;
                return [x, y];
            };

            const drawRings = (rings) => {
                rings.forEach((ring) => {
                    ring.forEach((coord, index) => {
                        const [x, y] = project(coord);
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.closePath();
                });
            };

            countryFeatures.forEach((feature) => {
                const geometry = feature?.geometry;
                if (!geometry) {
                    return;
                }

                const value = getTotalLength(feature?.properties);
                const t = Math.min(1, Math.max(0, (value - min) / range));
                const [r, g, b] = samplePalette(t);

                ctx.beginPath();
                if (geometry.type === "Polygon") {
                    drawRings(geometry.coordinates);
                } else if (geometry.type === "MultiPolygon") {
                    geometry.coordinates.forEach((polygon) => drawRings(polygon));
                } else {
                    return;
                }

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                ctx.strokeStyle = "rgba(15, 23, 42, 0.18)";
                ctx.lineWidth = 0.4;
                ctx.fill("evenodd");
                ctx.stroke();
            });

            const minLabel = document.getElementById("length-legend-min");
            const maxLabel = document.getElementById("length-legend-max");
            const legendBar = document.getElementById("length-legend-bar");
            if (minLabel && maxLabel && legendBar) {
                minLabel.textContent = `${formatNumber(min, { maximumFractionDigits: 0 })} km`;
                maxLabel.textContent = `${formatNumber(max, { maximumFractionDigits: 0 })} km`;
                const gradientStops = lengthPalette
                    .map((color, index) => {
                        const pct = (index / (lengthPalette.length - 1)) * 100;
                        return `rgb(${color[0]}, ${color[1]}, ${color[2]}) ${pct}%`;
                    })
                    .join(", ");
                legendBar.style.background = `linear-gradient(90deg, ${gradientStops})`;
            }
        };

        const renderDensityChoropleth = () => {
            const canvas = document.getElementById("density-choropleth");
            if (!canvas || !countryFeatures.length) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return;
            }

            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);

            const ctx = canvas.getContext("2d");
            if (!ctx) {
                return;
            }
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);

            const values = countryFeatures
                .map((feature) => getDensityValue(feature?.properties))
                .filter((value) => Number.isFinite(value) && value > 0);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;

            const densityPalette = [
                [224, 242, 254],
                [248, 180, 180],
                [239, 68, 68],
                [190, 82, 160],
                [124, 58, 237],
                [76, 29, 149]
            ];

            const lerp = (a, b, t) => a + (b - a) * t;
            const samplePalette = (t) => {
                const scaled = t * (densityPalette.length - 1);
                const idx = Math.floor(scaled);
                const frac = scaled - idx;
                const start = densityPalette[idx];
                const end = densityPalette[Math.min(idx + 1, densityPalette.length - 1)];
                return [
                    Math.round(lerp(start[0], end[0], frac)),
                    Math.round(lerp(start[1], end[1], frac)),
                    Math.round(lerp(start[2], end[2], frac))
                ];
            };

            const project = ([lon, lat]) => {
                const x = ((lon + 180) / 360) * rect.width;
                const y = ((90 - lat) / 180) * rect.height;
                return [x, y];
            };

            const drawRings = (rings) => {
                rings.forEach((ring) => {
                    ring.forEach((coord, index) => {
                        const [x, y] = project(coord);
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.closePath();
                });
            };

            countryFeatures.forEach((feature) => {
                const geometry = feature?.geometry;
                if (!geometry) {
                    return;
                }

                const value = getDensityValue(feature?.properties);
                const t = Math.min(1, Math.max(0, (value - min) / range));
                const [r, g, b] = samplePalette(t);

                ctx.beginPath();
                if (geometry.type === "Polygon") {
                    drawRings(geometry.coordinates);
                } else if (geometry.type === "MultiPolygon") {
                    geometry.coordinates.forEach((polygon) => drawRings(polygon));
                } else {
                    return;
                }

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                ctx.strokeStyle = "rgba(15, 23, 42, 0.18)";
                ctx.lineWidth = 0.4;
                ctx.fill("evenodd");
                ctx.stroke();
            });

            const minLabel = document.getElementById("density-legend-min");
            const maxLabel = document.getElementById("density-legend-max");
            const legendBar = document.getElementById("density-legend-bar");
            if (minLabel && maxLabel && legendBar) {
                minLabel.textContent = formatNumber(min, { maximumFractionDigits: 1 });
                maxLabel.textContent = formatNumber(max, { maximumFractionDigits: 1 });
                const gradientStops = densityPalette
                    .map((color, index) => {
                        const pct = (index / (densityPalette.length - 1)) * 100;
                        return `rgb(${color[0]}, ${color[1]}, ${color[2]}) ${pct}%`;
                    })
                    .join(", ");
                legendBar.style.background = `linear-gradient(90deg, ${gradientStops})`;
            }
        };

        let yieldScatterPoints = [];

        const renderYieldScatterplot = () => {
            const canvas = document.getElementById("yield-scatterplot");
            if (!canvas || !countryFeatures.length) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return;
            }

            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);

            const ctx = canvas.getContext("2d");
            if (!ctx) {
                return;
            }
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);

            const continentColors = {
                Africa: "#f97316",
                Asia: "#2563eb",
                Europe: "#7c3aed",
                Americas: "#facc15",
                Oceania: "#0ea5e9",
                Antarctica: "#64748b"
            };

            const rows = countryFeatures
                .map((feature) => ({
                    name: feature?.properties?.name || "Unknown",
                    density: getDensityValue(feature?.properties),
                    yield: feature?.properties?.cereal_yield || 0,
                    length: getTotalLength(feature?.properties),
                    continent: feature?.properties?.continent || "Other"
                }))
                .filter((row) => Number.isFinite(row.density) && Number.isFinite(row.yield));

            if (!rows.length) {
                return;
            }

            const pad = 34;
            const xMin = Math.min(...rows.map((row) => row.density));
            const xMax = Math.max(...rows.map((row) => row.density));
            const yMin = Math.min(...rows.map((row) => row.yield));
            const yMax = Math.max(...rows.map((row) => row.yield));
            const lenMin = Math.min(...rows.map((row) => row.length));
            const lenMax = Math.max(...rows.map((row) => row.length));

            const scale = (value, min, max, size) =>
                pad + ((value - min) / (max - min || 1)) * (size - pad * 2);

            ctx.strokeStyle = "rgba(148, 163, 184, 0.6)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad, pad);
            ctx.lineTo(pad, rect.height - pad);
            ctx.lineTo(rect.width - pad, rect.height - pad);
            ctx.stroke();

            ctx.strokeStyle = "rgba(148, 163, 184, 0.25)";
            ctx.lineWidth = 0.5;
            ctx.setLineDash([3, 3]);
            for (let i = 1; i <= 4; i += 1) {
                const x = pad + (i / 5) * (rect.width - pad * 2);
                const y = pad + (i / 5) * (rect.height - pad * 2);
                ctx.beginPath();
                ctx.moveTo(x, pad);
                ctx.lineTo(x, rect.height - pad);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pad, y);
                ctx.lineTo(rect.width - pad, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            const tickCount = 5;
            ctx.strokeStyle = "rgba(100, 116, 139, 0.7)";
            ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
            ctx.lineWidth = 1;
            ctx.font = "10px Inter, sans-serif";

            for (let i = 0; i <= tickCount; i += 1) {
                const t = i / tickCount;
                const x = pad + t * (rect.width - pad * 2);
                const y = rect.height - pad - t * (rect.height - pad * 2);
                const xValue = xMin + t * (xMax - xMin);
                const yValue = yMin + t * (yMax - yMin);

                ctx.beginPath();
                ctx.moveTo(x, rect.height - pad);
                ctx.lineTo(x, rect.height - pad + 4);
                ctx.stroke();
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.fillText(formatNumber(xValue, { maximumFractionDigits: 1 }), x, rect.height - pad + 6);

                ctx.beginPath();
                ctx.moveTo(pad - 4, y);
                ctx.lineTo(pad, y);
                ctx.stroke();
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.fillText(formatNumber(yValue, { maximumFractionDigits: 1 }), pad - 6, y);
            }

            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.font = "11px Inter, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(
                "Canal density (km/1000 km2 of cropland)",
                rect.width / 2,
                rect.height - 10
            );

            ctx.save();
            ctx.translate(6, rect.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.fillText("Cereal yield (tonnes/ha)", 0, 0);
            ctx.restore();

            yieldScatterPoints = [];

            rows.forEach((row) => {
                const x = scale(row.density, xMin, xMax, rect.width);
                const y = rect.height - scale(row.yield, yMin, yMax, rect.height);
                const t = (row.length - lenMin) / (lenMax - lenMin || 1);
                const radius = 3 + t * 8;

                ctx.beginPath();
                const color = continentColors[row.continent] || "#64748b";
                ctx.fillStyle = `${color}99`;
                ctx.strokeStyle = "rgba(124, 45, 18, 0.35)";
                ctx.lineWidth = 0.5;
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                yieldScatterPoints.push({
                    x,
                    y,
                    r: radius,
                    name: row.name,
                    density: row.density,
                    yield: row.yield,
                    length: row.length,
                    continent: row.continent
                });
            });

            const legendEl = document.getElementById("yield-legend");
            if (legendEl) {
                legendEl.innerHTML = "";
                const entries = Array.from(
                    new Set(
                        rows
                            .map((row) => row.continent)
                            .filter(Boolean)
                    )
                ).sort((a, b) => a.localeCompare(b));

                entries.forEach((continent) => {
                    const item = document.createElement("div");
                    item.className = "insights-legend-item";

                    const swatch = document.createElement("span");
                    swatch.className = "insights-legend-swatch";
                    swatch.style.background = continentColors[continent] || "#64748b";

                    const label = document.createElement("span");
                    label.className = "insights-legend-label";
                    label.textContent = continent;

                    item.appendChild(swatch);
                    item.appendChild(label);
                    legendEl.appendChild(item);
                });
            }

            const sizeSmall = document.getElementById("yield-size-small");
            const sizeMedium = document.getElementById("yield-size-medium");
            const sizeLarge = document.getElementById("yield-size-large");
            if (sizeSmall && sizeMedium && sizeLarge) {
                sizeSmall.textContent = `${formatNumber(lenMin, { maximumFractionDigits: 0 })} km`;
                sizeMedium.textContent = `${formatNumber(lenMin + (lenMax - lenMin) * 0.5, { maximumFractionDigits: 0 })} km`;
                sizeLarge.textContent = `${formatNumber(lenMax, { maximumFractionDigits: 0 })} km`;
            }
        };

        const setInsightsOpen = (open) => {
            document.body.classList.toggle("insights-open", open);
            insightsTab.setAttribute("aria-expanded", open ? "true" : "false");
            insightsPanel.setAttribute("aria-hidden", open ? "false" : "true");
            if (open) {
                const isLengthActive = document.querySelector(
                    '.insights-tab-button[aria-selected="true"][data-insights-tab="length"]'
                );
                if (isLengthActive) {
                    renderLengthChoropleth();
                    renderLengthBars();
                }
                const isDensityActive = document.querySelector(
                    '.insights-tab-button[aria-selected="true"][data-insights-tab="density"]'
                );
                if (isDensityActive) {
                    renderDensityChoropleth();
                    renderDensityBars();
                }
                const isYieldActive = document.querySelector(
                    '.insights-tab-button[aria-selected="true"][data-insights-tab="yield"]'
                );
                if (isYieldActive) {
                    renderYieldScatterplot();
                }
            }
        };

        insightsTab.addEventListener("click", () => {
            setInsightsOpen(!document.body.classList.contains("insights-open"));
        });

        insightsClose.addEventListener("click", () => {
            setInsightsOpen(false);
        });

        map.on("click", () => {
            if (document.body.classList.contains("insights-open")) {
                setInsightsOpen(false);
            }
        });

        if (yieldCanvas && yieldTooltip) {
            const hideYieldTooltip = () => {
                yieldTooltip.setAttribute("aria-hidden", "true");
                yieldTooltip.style.opacity = "0";
            };

            yieldCanvas.addEventListener("mouseleave", hideYieldTooltip);
            yieldCanvas.addEventListener("mousemove", (event) => {
                if (insightsPanel.getAttribute("aria-hidden") === "true") {
                    hideYieldTooltip();
                    return;
                }

                const rect = yieldCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                let closest = null;
                let minDistance = Infinity;
                yieldScatterPoints.forEach((point) => {
                    const dx = x - point.x;
                    const dy = y - point.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= point.r + 2 && distance < minDistance) {
                        minDistance = distance;
                        closest = point;
                    }
                });

                if (!closest) {
                    hideYieldTooltip();
                    return;
                }

                yieldTooltip.innerHTML = `
                    <strong>${closest.name}</strong><br />
                    Density: ${formatNumber(closest.density, { maximumFractionDigits: 1 })} km/1000 km<sup>2</sup><br />
                    Cereal yield: ${formatNumber(closest.yield, { maximumFractionDigits: 1 })} tonnes/ha<br />
                    Canal length: ${formatNumber(closest.length, { maximumFractionDigits: 0 })} km
                `;
                yieldTooltip.style.left = `${Math.min(rect.width - 160, x + 12)}px`;
                yieldTooltip.style.top = `${Math.max(6, y - 10)}px`;
                yieldTooltip.style.opacity = "1";
                yieldTooltip.setAttribute("aria-hidden", "false");
            });
        }

        insightsButtons.forEach((button) => {
            button.addEventListener("click", () => {
                insightsButtons.forEach((btn) => btn.setAttribute("aria-selected", "false"));
                button.setAttribute("aria-selected", "true");
                const panelName = button.dataset.insightsTab;
                insightsPanels.forEach((panel) => {
                    panel.hidden = panel.dataset.insightsPanel !== panelName;
                });
                if (panelName === "length") {
                    renderLengthChoropleth();
                    renderLengthBars();
                }
                if (panelName === "density") {
                    renderDensityChoropleth();
                    renderDensityBars();
                }
                if (panelName === "yield") {
                    renderYieldScatterplot();
                }
            });
        });

        window.addEventListener("resize", () => {
            const isLengthActive = document.querySelector(
                '.insights-tab-button[aria-selected="true"][data-insights-tab="length"]'
            );
            if (isLengthActive && insightsPanel.getAttribute("aria-hidden") === "false") {
                renderLengthChoropleth();
                renderLengthBars();
            }
            const isDensityActive = document.querySelector(
                '.insights-tab-button[aria-selected="true"][data-insights-tab="density"]'
            );
            if (isDensityActive && insightsPanel.getAttribute("aria-hidden") === "false") {
                renderDensityChoropleth();
                renderDensityBars();
            }
            const isYieldActive = document.querySelector(
                '.insights-tab-button[aria-selected="true"][data-insights-tab="yield"]'
            );
            if (isYieldActive && insightsPanel.getAttribute("aria-hidden") === "false") {
                renderYieldScatterplot();
            }
        });

        const countrySelect = document.getElementById("country-select");
        let countryFeatures = [];
        const GLOBAL_STATS = {
            length: 3.82,
            density: 200.1,
            cropland: 39.48
        };

        const statLength = document.getElementById("stat-length");
        const statLengthUnit = document.getElementById("stat-length-unit");
        const statCropland = document.getElementById("stat-cropland");
        const statCroplandUnit = document.getElementById("stat-cropland-unit");
        const statDensity = document.getElementById("stat-density");
        const statDensityUnit = document.getElementById("stat-density-unit");

        const formatNumber = (value, options = {}) =>
            new Intl.NumberFormat("en-US", options).format(value);

        const setGlobalStats = () => {
            statLength.textContent = GLOBAL_STATS.length;
            statLengthUnit.textContent = "million km";
            statCropland.textContent = GLOBAL_STATS.cropland;
            statCroplandUnit.innerHTML = "million km<sup>2</sup>";
            statDensity.textContent = GLOBAL_STATS.density;
            statDensityUnit.innerHTML = "km/1000km<sup>2</sup> of cropland";
        };

        const setCountryStats = (properties) => {
            const totalLength =
                (properties?.Agricultural || 0) +
                (properties?.urban_length || 0) +
                (properties?.navigational_length || 0) +
                (properties?.Other || 0);

            statLength.textContent = formatNumber(totalLength, { maximumFractionDigits: 1 });
            statLengthUnit.textContent = "km";

            statCropland.textContent = formatNumber(properties?.cropland_area_km2 || 0, {
                maximumFractionDigits: 0
            });
            statCroplandUnit.innerHTML = "km<sup>2</sup>";

            statDensity.textContent = formatNumber(properties?.canal_density || 0, {
                maximumFractionDigits: 1
            });
            statDensityUnit.innerHTML = "km/1000km<sup>2</sup> of cropland";
        };

        const populateCountries = async () => {
            try {
                const response = await fetch("assets/grain_country_stats.geojson");
                if (!response.ok) {
                    throw new Error(`Failed to load country stats (${response.status})`);
                }
                const data = await response.json();
                countryFeatures = data.features || [];
                renderLengthChoropleth();
                renderLengthBars();
                renderDensityChoropleth();
                renderDensityBars();
                renderYieldScatterplot();
                const names = Array.from(new Set(
                    countryFeatures
                        .map((feature) => feature?.properties?.name)
                        .filter(Boolean)
                )).sort((a, b) => a.localeCompare(b));

                countrySelect.innerHTML = "";
                const globalOption = document.createElement("option");
                globalOption.value = "global";
                globalOption.textContent = "Global";
                countrySelect.appendChild(globalOption);

                const divider = document.createElement("option");
                divider.disabled = true;
                divider.textContent = "──────────";
                countrySelect.appendChild(divider);

                const fragment = document.createDocumentFragment();
                names.forEach((name) => {
                    const option = document.createElement("option");
                    option.value = name;
                    option.textContent = name;
                    fragment.appendChild(option);
                });
                countrySelect.appendChild(fragment);
            } catch (error) {
                console.error("Failed to populate countries:", error);
            }
        };

        populateCountries();

        countrySelect.addEventListener("change", () => {
            if (countrySelect.value === "global") {
                map.flyTo({ center: [0, 20], zoom: 1 });
                setGlobalStats();
                selectedCountryIso = null;
                updateGrainLineStyle();
                return;
            }

            const selected = countryFeatures.find(
                (feature) => feature?.properties?.name === countrySelect.value
            );
            const point = selected?.properties?.geo_point_2d;
            selectedCountryIso = selected?.properties?.iso3 || null;
            updateGrainLineStyle();
            if (!point || typeof point.lon !== "number" || typeof point.lat !== "number") {
                return;
            }

            setCountryStats(selected?.properties);
            map.flyTo({ center: [point.lon, point.lat], zoom: 5 });
        });
    </script>
</body>

</html>
